# Алгоритмы для Bluetooth навигации в помещениях

## 1. Определение местоположения по BLE-маячкам

### 1.1 Метод трилатерации

Трилатерация - это метод определения местоположения объекта на основе расстояний до известных точек (в нашем случае - BLE-маячков).

#### Математическая модель:
Для определения положения пользователя (x, y) в двумерном пространстве требуется как минимум 3 маячка с известными координатами (x_i, y_i).

Уравнения:
- (x - x₁)² + (y - y₁)² = d₁²
- (x - x₂)² + (y - y₂)² = d₂²
- (x - x₃)² + (y - y₃)² = d₃²

Где d_i - расстояния от пользователя до i-го маячка.

### 1.2 Оценка расстояния по RSSI

RSSI (Received Signal Strength Indicator) - это показатель уровня принимаемого сигнала, который коррелирует с расстоянием до маячка.

#### Формула для оценки расстояния:
d = 10^((RSSI - A) / (-10 * n))

Где:
- d - оценочное расстояние до маячка
- RSSI - измеренное значение силы сигнала
- A - RSSI на расстоянии 1 метра (определяется экспериментально)
- n - коэффициент затухания сигнала (обычно от 2 до 4)

### 1.3 Фильтрация RSSI-сигнала

RSSI-сигнал подвержен шуму и флуктуациям. Для повышения точности используются фильтры:

#### Скользящее среднее:
```
filtered_RSSI = (RSSI_1 + RSSI_2 + ... + RSSI_n) / n
```

#### Фильтр Калмана:
- Более сложный, но эффективный метод для фильтрации шумных измерений
- Учитывает динамику движения пользователя

## 2. Алгоритмы построения маршрута

### 2.1 Алгоритм A*

A* - это популярный алгоритм поиска кратчайшего пути в графе с весами.

#### Псевдокод:
```
function A*(start, goal)
    closedSet := {}
    openSet := {start}
    gScore[start] := 0
    fScore[start] := gScore[start] + heuristic_cost_estimate(start, goal)
    
    while openSet is not empty
        current := the node in openSet having the lowest fScore[] value
        if current = goal
            return reconstruct_path(cameFrom, current)
        
        openSet.Remove(current)
        closedSet.Add(current)
        
        for each neighbor of current
            if neighbor in closedSet
                continue
            tentative_gScore := gScore[current] + dist_between(current, neighbor)
            
            if neighbor not in openSet
                openSet.Add(neighbor)
            else if tentative_gScore >= gScore[neighbor]
                continue
            
            cameFrom[neighbor] := current
            gScore[neighbor] := tentative_gScore
            fScore[neighbor] := gScore[neighbor] + heuristic_cost_estimate(neighbor, goal)
    
    return failure
```

### 2.2 Алгоритм Дейкстры

Альтернатива A*, более простой, но менее эффективный для больших графов.

## 3. Алгоритмы отслеживания движения

### 3.1 Предсказание траектории

На основе предыдущих координат и времени можно предсказать следующее положение пользователя.

### 3.2 Фильтрация траектории

Использование фильтров (например, фильтра Калмана) для сглаживания траектории движения и устранения шума.

## 4. Калибровка системы

### 4.1 Определение параметров RSSI

- TX Power: уровень сигнала на расстоянии 1 метра
- Коэффициент n: зависит от среды распространения сигнала
- Эти параметры определяются экспериментально для каждого помещения

### 4.2 Картографирование

- Создание карты помещения с координатами маячков
- Учет препятствий и зон с плохим покрытием
- Построение графа для алгоритмов маршрутизации